<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="https://d3js.org/d3-ease.v1.min.js"></script>


    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>

<body>
    <h1 class="white center padding">BigMacPrices</h1>
    <div id="mapContainer">
    </div>

    <select class="margin" id="countries">
        <option selected>Choose country...</option>
    </select>

    <script>

        const width = innerWidth;
        const height = innerHeight;
        let linechart;
        var colorHelper = [];


        const svg = d3.select("#mapContainer").append("svg")
            .attr("id", "mapSvg")
            .attr("width", width)
            .attr("height", height * 0.95);


        const projection = d3.geoNaturalEarth1()
            .scale(230)
            .translate([width / 2.25, height / 2.15]);
        const pathGenerator = d3.geo.path().projection(projection);

        const mapGroup = svg.append('g');

        mapGroup.append('path')
            .attr('class', 'sphere')
            .attr('d', pathGenerator({ type: "Sphere" }));


        const zoomLevelLimit = [1, 5];
        const zoom = d3.behavior.zoom().scaleExtent(zoomLevelLimit)

        svg.call(zoom.on('zoom', () => {
            mapGroup.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        }));
        //loading data for map
        d3.json("topoJSONdata.json", function (error, topoJSONdata) {
            //loading other data for each country
            d3.json("bigmacJSON.json", function (error, jsonData) {
                // Extracting the data from the JSON file
                const countries = topojson.feature(topoJSONdata, topoJSONdata.objects.countries);
                //row from file
                const rowById = {};
                var countryNames = [];
                var countriesHelper = [];
                jsonData.forEach(d => {
                    rowById[d.currency_Code] = d;
                    countryNames.push(rowById.undefined.name);
                    countriesHelper.push(rowById.undefined);

                });

                countryNames = [...new Set(countryNames.map((r) => r))];
                console.log('helperh', countriesHelper);
                //RADI DOLJE
                // Create a map to store the sum and count of dollar_price for each unique name
                const nameData = new Map();

                // Iterate over the JSON objects and calculate sum and count for each unique name
                jsonData.forEach(item => {
                    const name = item.name;
                    const price = parseFloat(item.dollar_price);

                    if (nameData.has(name)) {
                        nameData.get(name).sum += price;
                        nameData.get(name).count += 1;
                    } else {
                        nameData.set(name, { sum: price, count: 1 });
                    }
                });

                // Calculate the average for each unique name
                const averages = new Map();
                nameData.forEach((values, name) => {
                    averages.set(name, values.sum / values.count);
                });

                // Print the average dollar_price for each unique name
                averages.forEach((average, name) => {
                    console.log(`${name}: ${average}`);
                });

                //RADI GORE
                //ISKORISTI ONAJ KOD ZA BOJE NA KARTI



                countries.features.forEach(d => {
                    Object.assign(d.properties, rowById[d.id])
                });
                

                


                //putting countries in select element
                countryNames.sort();
                const dropDown = d3.select("#countries");
                dropDown.selectAll(null)
                    .data(countryNames)
                    .enter()
                    .append("option")
                    .attr("value", function (d) { return d; })
                    .text(function (d) { return d; });

                dropDown.on('change', function () {
                    const select = document.getElementById('countries');
                    const name = select.options[select.selectedIndex].value;
                    console.log('nameT', name);
                    var country = [];
                    console.log('tcountiries', countriesHelper);
                    country = countriesHelper.filter((r) => r.name == name)
                    console.log('TestCntry', country);
                    var graphData = [];
                    country.forEach((item) => {
                        graphData.push({
                            x: item.date,
                            y: item.dollar_price
                        })
                    })
                    console.log('graphDataTest', graphData);
                    makeGraphs(graphData);

                })

                //klik na džavu, kurca ne radi 

                mapGroup.selectAll('path')
                    .data(countries.features)
                    .enter()
                    .append('path')
                    .attr('class', 'country')
                    .attr('d', pathGenerator)
                    //.attr('fill', d => colors[String(colorValue(d)).substring(0, 1) - 1])
                    .on('click', d => {
                        //disable click when dragging over map
                        if (d3.event.defaultPrevented) return;
                        var country = [];
                        console.log('tcountiries', countriesHelper);
                        country = countriesHelper.filter((r) => r.name == name)
                        var graphData = [];
                        country.forEach((item) => {
                            graphData.push({
                                x: item.date,
                                y: item.dollar_price
                            })
                        })
                        makeGraphs(graphData);
                    })
                    .append('title')
                    .text(d => {
                        const name = rowById[d.id].name;
                        return name;
                    })
            });
        });
        function getDate(d) {
            return new Date(d.jsonDate);
        }

        let graphMade = false;

        function makeGraphs(data) {
            if (graphMade) {
                graphGroup.remove();
                linechart.remove();
                graphSvg.selectAll(".bar").remove();
                graphSvg.selectAll(".removeable").remove();
                graphGroup = graphSvg.append('g');
            }
            window.scrollTo(0, document.body.scrollHeight);
            const margin = { top: 20, bottom: 70, left: 40, right: 20 };
            const width = 750 - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;


            const graphSvg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height * 0.75);

            // get max and min dates - this assumes data is sorted
            var minDate = getDate(data[0]);
            var maxDate = getDate(data[data.length - 1]);

            var x = d3.time.scale().domain([minDate, maxDate]).range([0, width])

            var y = d3.scale
                .linear()
                .domain([
                    0,
                    d3.max(data.map((d) => d.y), function (d) {
                        return d;
                    }),
                ])
                .range([height, 0]);
            var outFormat = d3.time.format("%d-%m-%y");
            var xAxis = d3.graphSvg.axis().scale(x).orient("bottom").ticks(20);
            var yAxis = d3.graphSvg.axis().scale(y).orient("left").ticks(30);

            graphSvg
                .append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis)
                .selectAll("text")
                .style("text-anchor", "middle");

            graphSvg
                .append("text")
                .attr("x", width / 2)
                .attr("y", -(margin.top / 2))
                .attr("font-weight", "bold")
                .style("font-size", "20px")
                .style("text-anchor", "middle")
                .text(
                    "Cijene BigMac sendviča."
                );

            graphSvg
                .append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -(height / 2))
                .attr("y", -(margin.left / 2 + 20))
                .style("text-anchor", "middle")
                .text("Cijena u dolarima")
                .style("font-size", "13px");

            graphSvg
                .append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Datum");

            var valueline = d3.graphSvg
                .line()
                .interpolate("cardinal")
                .x(function (d) {
                    return x(getDate(d.x));
                })
                .y(function (d) {
                    return y(d.y);
                });
            const graphData = data.filter((d) => {
                if (isNaN(d.x)) return false
                if (isNaN(d.y)) return false
                return true
            })
            var linechart = graphSvg
                .append("path")
                .attr("class", "line")
                .attr("d", valueline(graphData))
                .style("stroke", "blue")
                .attr("fill", "none");
            graphMade = true;
        }


        //for displaying big numbers
        function numberWithSpaces(x) {
            return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
        }
        function parseData(data) {
            if (!data.toString().includes(",")) {
                return 0;
            }
            const commmaIndex = data.toString().indexOf(",");
            const value = data.toString().substring(0, commmaIndex);
            return parseInt(parseInt(value) / 1000000000);
        }
    </script>

</body>

</html>